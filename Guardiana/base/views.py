import hashlib
from django import forms
from django.http import HttpResponseRedirect, JsonResponse
from django.shortcuts import render
from django.urls import reverse
from transformers import pipeline
import pandas as pd 
import numpy as np 
import pefile
import pickle
import joblib
import requests
import json
from django.views.decorators.csrf import csrf_exempt
from django.core import serializers
from django.forms.models import model_to_dict

from .models import Executables


# Create your views here.
def index(request):
    # return render(request, 'index.html')
    data = {'message': 'Hello from Django!'}
    return JsonResponse(data)

def upload_executable(request):
    if request.method == 'GET':
        return render(request, 'upload.html')  # Return the rendered template

@csrf_exempt
def getback(request):
    if request.method == "POST":
        print("post")
        filler_resume = request.FILES.get('file', '')
        features = extract_pe_features(filler_resume)
        filler_resume.seek(0)
        file_content = filler_resume.read()
        hash_value = calculate_hash(file_content)
        # Convert boolean values to integers (0 and 1)
        try:
                executable = Executables.objects.filter(hash=hash_value).first()
                # Convert model instance to dictionary
                executable_dict = model_to_dict(executable)
                # Optionally, update the response_data if needed
                response_data = executable_dict
        except Exception as e:
            print(f"An error occurred: {e}")
            print("hello")
            for k, v in features.items():
                if isinstance(v, bool):
                    features[k] = int(v)
                elif isinstance(v, str) and v.lower() in ['true', 'false']:
                    features[k] = int(v.lower() == 'true')
            
            for feature, value in features.items():
                print(f"{feature}: {value}")
            
            feature_values = [list(features.values())]
            feature_names = list(features.keys())
            
            df = pd.DataFrame(feature_values, columns=feature_names)
            df.to_csv('extracted_features.csv', index=False)
            print(df)
            
            skew_list = ['NumberOfSections', 'TimeDateStamp', 'Characteristics', 'MajorLinkerVersion', 'MinorLinkerVersion', 'SizeOfCode', 'SizeOfInitializedData', 'SizeOfUninitializedData', 'AddressOfEntryPoint', 'BaseOfCode', 'FileAlignment', 'MajorOperatingSystemVersion', 'MajorImageVersion', 'SizeOfImage', 'SizeOfHeaders', 'CheckSum', 'text_Misc_VirtualSize', 'text_VirtualAddress', 'text_SizeOfRawData', 'text_PointerToRawData', 'data_Misc_VirtualSize', 'data_VirtualAddress', 'data_SizeOfRawData', 'data_PointerToRawData', 'rdata_Misc_VirtualSize', 'rdata_VirtualAddress', 'rdata_SizeOfRawData', 'rdata_PointerToRawData', 'rsrc_Misc_VirtualSize', 'rsrc_VirtualAddress', 'rsrc_SizeOfRawData', 'rsrc_PointerToRawData', 'rsrc_Characteristics', 'reloc_Misc_VirtualSize', 'reloc_VirtualAddress', 'reloc_SizeOfRawData', 'reloc_PointerToRawData']
            
            # Apply log1p transformation to selected columns and print the transformed DataFrame
            for column in skew_list:
                if column in df.columns:
                    df[column] = np.log1p(df[column])
            data_dict = df.to_dict()
            flat_dict = flatten_dict(data_dict)
            payload = {
                "body": flat_dict
                }
            payload_json = json.dumps(payload)
            
            # extra_features = ['text_Characteristics', 'data_Characteristics', 'rsrc_Characteristics', 'text_PointerToRawData']
            # df.drop(columns=extra_features, inplace=True)
            
            # with open('random_forest_samplified.pkl', 'rb') as file:
            #         rf_model = joblib.load('random_forest_samplified.pkl')
            
            # # Make predictions using the loaded model
            # predictions = rf_model.predict(df.values)
            # predictions_list = predictions.tolist()
            # # Print the predicted label on the terminal
            # print("Predicted label:", predictions_list)
            url="https://n5vdks2mge.execute-api.us-east-1.amazonaws.com/lambda"
            print(payload_json)
            response = requests.post(url, json=payload_json)
            print(response.json(),"this is the response")
            # Save data to database
            executable = Executables.objects.create(
                name=request.FILES['file'].name,
                hash=hash_value,
                features=feature_values,
                # prediction=predictions_list[0]
            )
            print(executable)
            executable_dict = model_to_dict(executable)
        

    # return render(request, "result.html",{"prediction":predictions})
    return JsonResponse(executable_dict)


def extract_pe_features(file_path):
    pe_features = {
   "virtualallocex": 0,
    "getversion": 0,
    "getprocaddress": 0,
    "getmodulefilenamew": 0,
    "getmodulehandlew": 0,
    "getmodulehandlea": 0,
    "raiseexception": 0,
    "exitprocess": 0,
    "getstartupinfow": 0,
    "heapalloc": 0,
    "terminateprocess": 0,
    "getconsolecp": 0,
    "getconsolemode": 0,
    "writeconsolew": 0,
    "loadlibrarya": 0,
    "virtualalloc": 0,
    "createprocessw": 0,
    "writeprocessmemory": 0,
    "corexemain": 0,
    "advapi32.dll": 0,
    "kernel32.dll": 0,
    "ole32.dll": 0,
    "oleaut32.dll": 0,
    "shlwapi.dll": 0,
    "user32.dll": 0,
    "msvcrt.dll": 0,
    "shell32.dll": 0,
    "version.dll": 0,
    "comctl32.dll": 0,
    "gdi32.dll": 0,
    "winmm.dll": 0,
    "comdlg32.dll": 0,
    "winhttp.dll": 0,
    "mscoree.dll": 0,
    "msvbvm60.dll": 0,
    "mfc42.dll": 0,
    "e_lfanew": 0,
    "NumberOfSections": 0,
    "TimeDateStamp": 0,
    "Characteristics": 0,
    "MajorLinkerVersion": 0,
    "MinorLinkerVersion": 0,
    "SizeOfCode": 0,
    "SizeOfInitializedData": 0,
    "SizeOfUninitializedData": 0,
    "AddressOfEntryPoint": 0,
    "BaseOfCode": 0,
    "SectionAlignment": 0,
    "FileAlignment": 0,
    "MajorOperatingSystemVersion": 0,
    "MajorImageVersion": 0,
    "SizeOfImage": 0,
    "SizeOfHeaders": 0,
    "CheckSum": 0,
    "DllCharacteristics": 0,
    "text_Misc_VirtualSize": 0,
    "text_VirtualAddress": 0,
    "text_SizeOfRawData": 0,
    "text_PointerToRawData": 0,
    "data_Misc_VirtualSize": 0,
    "data_VirtualAddress": 0,
    "data_SizeOfRawData": 0,
    "data_PointerToRawData": 0,
    "data_Characteristics": 0,
    "rdata_Misc_VirtualSize": 0,
    "rdata_VirtualAddress": 0,
    "rdata_SizeOfRawData": 0,
    "rdata_PointerToRawData": 0,
    "rsrc_Misc_VirtualSize": 0,
    "rsrc_VirtualAddress": 0,
    "rsrc_SizeOfRawData": 0,
    "rsrc_PointerToRawData": 0,
    "rsrc_Characteristics": 0,
    "reloc_Misc_VirtualSize": 0,
    "reloc_VirtualAddress": 0,
    "reloc_SizeOfRawData": 0,
    "reloc_PointerToRawData": 0,
    "reloc_Characteristics": 0


    }

    try:
        # Load the PE file
        pe = pefile.PE(data=file_path.read())

        # Extract individual features
        # if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
        #     exported_symbols = [entry.name.decode('utf-8').lower() for entry in pe.DIRECTORY_ENTRY_EXPORT.symbols]
        #     pe_features['corexemain'] = str('corexemain' in exported_symbols)
        # else:
        #     pe_features['corexemain'] = 0
        dlls_to_check = [
        "advapi32.dll", "kernel32.dll", "ole32.dll", "oleaut32.dll", "shlwapi.dll",
        "user32.dll", "msvcrt.dll", "shell32.dll", "version.dll", "comctl32.dll",
        "gdi32.dll", "winmm.dll", "comdlg32.dll", "winhttp.dll", "mscoree.dll",
        "msvbvm60.dll", "mfc42.dll"
        ]
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode("utf-8").lower()
            if dll_name in dlls_to_check:
                pe_features[dll_name] = 1

        api_functions_to_check = [
        "virtualallocex", "getversion", "getprocaddress", "getmodulefilenamew",
        "getmodulehandlew", "getmodulehandlea", "raiseexception", "exitprocess",
        "getstartupinfow", "heapalloc", "terminateprocess", "getconsolecp",
        "getconsolemode", "writeconsolew", "loadlibrarya", "virtualalloc",
        "createprocessw", "writeprocessmemory", "corexemain"
        ]

        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode("utf-8").lower()
            for imp in entry.imports:
                api_func_name = imp.name.decode("utf-8").lower()
                if api_func_name in api_functions_to_check:
                    pe_features[api_func_name] = 1



        # Extract PE header features
        pe_features['e_lfanew'] = pe.DOS_HEADER.e_lfanew
        pe_features['NumberOfSections'] = pe.FILE_HEADER.NumberOfSections
        pe_features['TimeDateStamp'] = pe.FILE_HEADER.TimeDateStamp
        pe_features['Characteristics'] = pe.FILE_HEADER.Characteristics
        pe_features['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
        pe_features['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
        pe_features["MajorOperatingSystemVersion"]= pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
        pe_features['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
        pe_features['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
        pe_features['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
        pe_features['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
        pe_features['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
        pe_features['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
        pe_features['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
        pe_features['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics

        # Extract section features
        for section in pe.sections:
            section_name = section.Name.decode('utf-8').rstrip('\x00').lower()
            if section_name == '.reloc':
                pe_features['reloc_Misc_VirtualSize'] = section.Misc_VirtualSize
                pe_features['reloc_VirtualAddress'] = section.VirtualAddress
                pe_features['reloc_SizeOfRawData'] = section.SizeOfRawData
                pe_features['reloc_PointerToRawData'] = section.PointerToRawData
                pe_features['reloc_Characteristics'] = section.Characteristics
            elif section_name == '.text':
                pe_features['text_Misc_VirtualSize'] = section.Misc_VirtualSize
                pe_features['text_VirtualAddress'] = section.VirtualAddress
                pe_features['text_SizeOfRawData'] = section.SizeOfRawData
                pe_features['text_PointerToRawData'] = section.PointerToRawData
                pe_features['text_Characteristics'] = section.Characteristics
            elif section_name == '.data':
                pe_features['data_Misc_VirtualSize'] = section.Misc_VirtualSize
                pe_features['data_VirtualAddress'] = section.VirtualAddress
                pe_features['data_SizeOfRawData'] = section.SizeOfRawData
                pe_features['data_PointerToRawData'] = section.PointerToRawData
                pe_features['data_Characteristics'] = section.Characteristics
            elif section_name == '.rsrc':
                pe_features['rsrc_Misc_VirtualSize'] = section.Misc_VirtualSize
                pe_features['rsrc_VirtualAddress'] = section.VirtualAddress
                pe_features['rsrc_SizeOfRawData'] = section.SizeOfRawData
                pe_features['rsrc_PointerToRawData'] = section.PointerToRawData
                pe_features['rsrc_Characteristics'] = section.Characteristics
            elif section_name ==".rdata":
                pe_features['rdata_Misc_VirtualSize'] = section.Misc_VirtualSize
                pe_features['rdata_VirtualAddress'] = section.VirtualAddress
                pe_features['rdata_SizeOfRawData'] = section.SizeOfRawData
                pe_features['rdata_PointerToRawData'] = section.PointerToRawData

                



        # Extract DLL features
        # pe_features['msvbvm60.dll'] = 1 if 'msvbvm60.dll' in [entry.dll.decode('utf-8').lower() for entry in pe.DIRECTORY_ENTRY_IMPORT] else 0

    except Exception as e:
        print(f"Error extracting features: {e}")
    return pe_features

@csrf_exempt
def vt_scan(request):
    if request.method =='POST': 
        url = "https://www.virustotal.com/api/v3/files"

        headers = {
        "accept": "application/json",
        "x-apikey": "7914be4a21b3705bf29e230d272e297d127b71e9262f069689800afbd50bf4ab",
        }
        file_data = request.FILES.get('file')
        print(file_data.name)
        if file_data:
            files = {'file': (file_data.name, file_data.file, file_data.content_type)}
            response = requests.post(url,files=files ,headers=headers)
            response1 =requests.get(url=json.loads(response.text)['data']['links']['self'],headers=headers)
            response_analysis = response1.json()
            print(response_analysis)
            return JsonResponse(response_analysis)
        else:
            print("No file uploaded")

    else:

        return render(request, 'vt.html')
    
def calculate_hash(file_content):
    # Initialize the hash object (SHA-256)
    hash_obj = hashlib.sha256()
    
    # Update hash object with the file content
    hash_obj.update(file_content)
    
    # Get the hexadecimal representation of the hash value
    hash_value = hash_obj.hexdigest()
    
    return hash_value

def get_all(request):
    queryset = Executables.objects.all();
    total_cases = queryset.count()
    prediction_counts = {i: queryset.filter(prediction=i).count() for i in range(7)}
    # Serialize queryset to JSON
    serialized_data = serializers.serialize('json', queryset)
    if isinstance(serialized_data, str):
    # Parse the JSON string into a Python object
        serialized_data = json.loads(serialized_data)

    
    # Convert serialized data to Python object
    fields_only = [entry['fields'] for entry in serialized_data]
    details = {
        'total_cases': total_cases,
        'prediction_counts': prediction_counts,
        'all_data':fields_only
    }
    return JsonResponse(details)

@csrf_exempt
def update_predict(request):
    if request.method =='POST':
        data = json.loads(request.body)
        hash_value = data.get('hash_value')
        print(hash_value)
        user_feedback = data.get('user_feedback')
        print(user_feedback)

        try:
            executable =  Executables.objects.filter(hash=hash_value).first()
        except Executables.DoesNotExist:
            return JsonResponse({"error": "Executable with provided hash does not exist."}, status=404)
        
        executable.user_feedback = user_feedback
        executable.save()
        return JsonResponse({"success": "User feedback updated successfully."})


def flatten_dict(d):
    flattened = {}
    for key, value in d.items():
        if isinstance(value, dict):
            for subkey, subvalue in value.items():
                flattened[key] = subvalue
        else:
            flattened[key] = value
    return flattened